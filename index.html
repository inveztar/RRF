<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Room Resonance Watch — v2.2 (Score + Gate + 3-row lock + NoteName)</title>
<style>
  /* ---------------------------------------------------------
     แพทหลังบ้าน (Patch Notes)
     - v2.2
       • แสดงชื่อ “โน้ต” กำกับถัดจาก Hz ในการ์ด Resonance Likelihood (Score)
     - v2.1
       • ล็อคตารางผล 3 แถวตายตัว (ไม่มีการดีดแถว) ถ้าไม่มีค่าโชว์ "—"
       • เพิ่ม Count Gate (dBFS) แบบสไลด์ เพื่อกันการนับช่วงเงียบ/นอยซ์
       • เก็บ Top Winner เฉพาะคลิปที่ “พีคอันดับ1” และดังเกิน Gate
       • คำนวณ Resonance Likelihood (Score) จาก Prominence, Hold, Count, Decay
       • ประมาณค่า Decay (= เวลาตั้งแต่จุดพีคจนตก ≥ 10dB)
       • Watchlist (Hz หรือโน้ต เช่น B2), Start/Stop, Clear
     --------------------------------------------------------- */

  :root{
    --bg:#0f141a; --panel:#16202a; --ink:#cfe3ff; --muted:#89a3bd; --accent:#5fb2ff;
    --ok:#36d399; --warn:#ff8f6b; --bad:#ff5c5c; --line:#243443;
  }
  html,body{background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,"Noto Sans",sans-serif;margin:0}
  .wrap{max-width:1100px;padding:18px;margin:0 auto}
  h1{margin:0 0 14px;font-size:22px}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  .card{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px}
  .card h3{margin:4px 0 10px;font-size:16px;color:var(--ink)}
  .btn{background:var(--accent);color:#062240;border:0;border-radius:10px;padding:8px 12px;font-weight:700;cursor:pointer}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .btn.sub{background:#334b63;color:var(--ink);font-weight:600}
  .ctl{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  input[type="number"], input[type="text"], select{
    background:#0e141b;border:1px solid var(--line);color:var(--ink);border-radius:8px;padding:8px 10px;min-width:120px
  }
  input[type="text"]{min-width:180px}
  .badge{display:inline-block;background:#243242;color:#9cc0ff;border-radius:999px;padding:3px 8px;font-size:12px;margin-left:8px}
  .muted{color:var(--muted);font-size:13px}
  .grid{width:100%;border-collapse:collapse}
  .grid th,.grid td{border-bottom:1px solid var(--line);padding:8px 6px;text-align:left}
  .grid th{color:#9cc0ff;font-weight:700;font-size:13px}
  .grid td{font-size:14px}
  .grid tr:last-child td{border-bottom:0}
  .mono{font-variant-numeric:tabular-nums}
  .ok{color:var(--ok)} .bad{color:var(--bad)} .warn{color:var(--warn)}
  .bar{height:8px;background:#233141;border-radius:8px;overflow:hidden}
  .bar>i{display:block;height:100%;background:linear-gradient(90deg,#2ad2c9,#5fb2ff 60%,#ff8f6b);width:0%}
  .pill{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--line);border-radius:999px;padding:6px 10px}
  .hl{background:#11263b;padding:2px 6px;border-radius:6px}
  .note{font-size:12px;color:#93aac4}
</style>
</head>
<body>
<div class="wrap">
  <h1>Resonance Watch — หาเรโซแนนซ์จากไมค์จริง <span class="badge">v2.2</span></h1>

  <div class="row">
    <div class="card" style="flex:1 1 560px;min-width:320px">
      <h3>ควบคุม</h3>
      <div class="ctl">
        <button id="btnStart" class="btn">เริ่มวัด</button>
        <button id="btnStop" class="btn sub" disabled>หยุด</button>
        <button id="btnClear" class="btn sub">Clear สถิติ</button>

        <label class="pill">
          ย่านตรวจ:
          <input id="minHz" type="number" value="40" min="10" max="18000" step="1">
          —
          <input id="maxHz" type="number" value="300" min="20" max="20000" step="1">
          Hz
        </label>

        <label class="pill">
          Count Gate ≥
          <input id="gate" type="range" min="-80" max="-10" step="1" value="-40">
          <span id="gateVal" class="mono hl">-40 dBFS</span>
        </label>
      </div>
      <div class="note" style="margin-top:8px">
        * จะนับสถิติ Top Winner เฉพาะคลิปที่ “พีคอันดับ1” และมีระดับสูงกว่า Gate เท่านั้น เพื่อตัดนอยซ์/ช่วงเงียบ
      </div>
    </div>

    <div class="card" style="flex:1 1 420px;min-width:280px">
      <h3>Watchlist</h3>
      <div class="ctl">
        <input id="wlHz" type="text" placeholder="Hz หรือ โน้ต เช่น B2" />
        <button id="btnAddWatch" class="btn sub">Add</button>
        <button id="btnClearWatch" class="btn sub">Clear Watchlist</button>
      </div>
      <div class="muted" id="watchlist" style="margin-top:8px">—</div>
    </div>
  </div>

  <div class="row" style="margin-top:12px">
    <div class="card" style="flex:1 1 560px;min-width:320px">
      <h3>พีคปัจจุบัน (ล็อค 3 แถว)</h3>
      <table class="grid" id="tblPeaks">
        <thead><tr>
          <th>Hz</th><th>Level (dBFS)</th><th>Prom. (dB)</th><th>Hold (s)</th><th>Decay (s)</th>
        </tr></thead>
        <tbody></tbody>
      </table>
    </div>

    <div class="card" style="flex:1 1 420px;min-width:280px">
      <h3>Top Winners (3 อันดับ)</h3>
      <table class="grid" id="tblWinners">
        <thead><tr><th>Hz</th><th>นับครั้ง</th></tr></thead>
        <tbody></tbody>
      </table>
      <div class="note">* นับเมื่อ Max Peak ชนะและดังเกิน Gate</div>
    </div>
  </div>

  <div class="card" style="margin-top:12px">
    <h3>Resonance Likelihood (Score)</h3>
    <div id="scores" class="row"></div>
    <div class="note" style="margin-top:8px">
      คะแนนคิดจาก Prominence (0–12dB), Hold (0–3s), Count (เทียบอันดับสูงสุด), Decay (0–1.5s) — ถ่วงน้ำหนัก 30/30/20/20
    </div>
  </div>

  <div class="muted" style="margin-top:12px">
    ผลลัพธ์ขึ้นกับไมค์และสภาพแวดล้อม ใช้ร่วมกับการลองปรับ EQ/Q แคบ ๆ เพื่อยืนยัน room mode
  </div>
</div>

<script>
(() => {
  // ====== Utilities ======
  const noteToHz = (s) => {
    // รับ เช่น "B2", "Bb3", "A#2"
    const A4 = 440;
    const re = /^([A-Ga-g])([#b]?)(-?\d+)$/;
    const m = (s||'').toString().trim().match(re);
    if(!m) return NaN;
    let n = m[1].toUpperCase();
    const acc = m[2];
    const oct = parseInt(m[3],10);
    const map = {C:-9,D:-7,E:-5,F:-4,G:-2,A:0,B:2};
    let semis = map[n] + (oct-4)*12;
    if(acc === '#') semis += 1; else if(acc==='b') semis -= 1;
    return +(A4*Math.pow(2,semis/12)).toFixed(2);
  };
  // แปลง Hz -> ชื่อโน้ต (ใกล้สุด)
  const hzToNoteName = (hz) => {
    if(!hz || hz<=0 || !isFinite(hz)) return '';
    const midi = Math.round(69 + 12*Math.log2(hz/440));
    const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    const name = names[((midi%12)+12)%12];
    const octave = Math.floor(midi/12) - 1;
    return `${name}${octave}`;
  };
  const fmt = (v,empty='—') => (v==null || Number.isNaN(v) ? empty : v);
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));

  // ====== State ======
  let ctx, analyser, data, raf;
  let sampleRate = 48000, fftSize = 4096;
  let minHz = 40, maxHz = 300;
  let gateDb = -40;

  const winners = new Map(); // freqRounded -> count
  const peakMemo = new Map(); // Decay memo: freqRounded -> {peakDb, t0, lastDecay}
  const holds = new Map();    // Hold memo:  freqRounded -> {tStart, lastSeen}
  let watch = []; // Watchlist in Hz

  // ====== DOM ======
  const btnStart = document.getElementById('btnStart');
  const btnStop  = document.getElementById('btnStop');
  const btnClear = document.getElementById('btnClear');
  const minHzEl = document.getElementById('minHz');
  const maxHzEl = document.getElementById('maxHz');
  const gateEl = document.getElementById('gate');
  const gateVal = document.getElementById('gateVal');
  const tblPeaks = document.getElementById('tblPeaks').querySelector('tbody');
  const tblWinners = document.getElementById('tblWinners').querySelector('tbody');
  const scoresBox = document.getElementById('scores');
  const wlHz = document.getElementById('wlHz');
  const btnAddWatch = document.getElementById('btnAddWatch');
  const btnClearWatch = document.getElementById('btnClearWatch');
  const watchlistDiv = document.getElementById('watchlist');

  const hzPerBin = () => sampleRate/fftSize;
  const binOf = (hz) => Math.round(hz / hzPerBin());
  const hzOf  = (bin) => bin * hzPerBin();

  // ====== UI events ======
  minHzEl.onchange = ()=>{minHz = +minHzEl.value||40};
  maxHzEl.onchange = ()=>{maxHz = +maxHzEl.value||300};
  gateEl.oninput   = ()=>{gateDb = +gateEl.value; gateVal.textContent = gateDb.toFixed(0)+' dBFS'};

  btnAddWatch.onclick = ()=>{
    const v = wlHz.value.trim();
    if(!v) return;
    let hz = +v;
    if(Number.isNaN(hz)) hz = noteToHz(v);
    if(Number.isNaN(hz) || hz<=0) return alert('ใส่เป็น Hz หรือโน้ต เช่น B2');
    watch.push(hz);
    renderWatchlist();
    wlHz.value='';
  };
  btnClearWatch.onclick = ()=>{watch=[]; renderWatchlist()};

  btnStart.onclick = start;
  btnStop.onclick  = stop;
  btnClear.onclick = () => {winners.clear(); peakMemo.clear(); holds.clear(); renderWinners();};

  function renderWatchlist(){
    if(!watch.length){watchlistDiv.textContent='—'; return;}
    watchlistDiv.innerHTML = watch.map(h=>`<span class="hl mono">${h.toFixed(2)} Hz</span>`).join(' ');
  }

  // ====== Audio Init ======
  async function start(){
    btnStart.disabled = true;
    try{
      const stream = await navigator.mediaDevices.getUserMedia({audio:{
        echoCancellation:false,noiseSuppression:false,autoGainControl:false
      }});
      ctx = new AudioContext();
      sampleRate = ctx.sampleRate;
      analyser = ctx.createAnalyser();
      analyser.fftSize = fftSize;
      analyser.smoothingTimeConstant = 0.0;
      analyser.minDecibels = -100;
      analyser.maxDecibels = -20;
      const src = ctx.createMediaStreamSource(stream);
      src.connect(analyser);
      data = new Float32Array(analyser.frequencyBinCount);
      btnStop.disabled = false;
      loop();
    }catch(e){
      console.error(e);
      alert('ไม่สามารถเปิดไมค์ได้');
      btnStart.disabled=false;
    }
  }
  function stop(){
    btnStop.disabled = true;
    if(ctx) ctx.close();
    ctx=null; cancelAnimationFrame(raf); raf=0;
    btnStart.disabled=false;
  }

  // ====== Peak find + metrics ======
  function getPeaks(){
    analyser.getFloatFrequencyData(data);
    const minBin = clamp(binOf(minHz),0,data.length-1);
    const maxBin = clamp(binOf(maxHz),0,data.length-1);

    // วัด Overall เพื่อใช้ Gate
    let overall = -120;
    for(let i=minBin;i<=maxBin;i++) overall = Math.max(overall,data[i]);

    // หา local maxima (แบบง่าย)
    const cands=[];
    for(let i=minBin+2;i<=maxBin-2;i++){
      const v = data[i];
      if(v<=data[i-1] || v<=data[i+1]) continue;
      const neigh = (data[i-2]+data[i-1]+data[i+1]+data[i+2])/4;
      const prom = v - neigh;
      cands.push({bin:i, hz:hzOf(i), level:v, prom});
    }
    cands.sort((a,b)=>b.prom-a.prom);

    const chosen=[];
    for(const p of cands){
      if(chosen.length>=3) break;
      if(p.prom<1.5) continue;
      if(chosen.some(q=>Math.abs(q.bin-p.bin)<2)) continue;
      // decay ประเมินจาก peakMemo
      const rHz = Math.round(p.hz);
      let dec = null;
      const memo = peakMemo.get(rHz);
      const now = performance.now()/1000;
      if(!memo || p.level > memo.peakDb){
        peakMemo.set(rHz,{peakDb:p.level,t0:now,lastDecay:memo?.lastDecay ?? null});
      }else{
        const drop = memo.peakDb - p.level;
        if(drop >= 10){
          dec = now - memo.t0;
          peakMemo.set(rHz,{peakDb:p.level,t0:now,lastDecay:dec});
        }else{
          dec = memo?.lastDecay ?? null;
        }
      }
      chosen.push({...p, decay:dec});
    }
    return {peaks:chosen, overall};
  }

  function updateHolds(peaks){
    const now = performance.now()/1000;
    const seen = new Set();
    for(const p of peaks){
      const k = Math.round(p.hz);
      seen.add(k);
      let h = holds.get(k);
      if(!h){ h={tStart:now,lastSeen:now}; holds.set(k,h); }
      h.lastSeen = now;
    }
    for(const [k,h] of holds){
      if(now - h.lastSeen > 0.5) holds.delete(k);
    }
    for(const p of peaks){
      const k = Math.round(p.hz);
      const h = holds.get(k);
      p.holdSec = h? (now - h.tStart) : 0;
    }
  }

  // Winners count (อันดับ1 + gate)
  function updateWinners(peaks, overall){
    if(overall < gateDb) return;
    if(!peaks.length) return;
    const p = peaks[0];
    const key = Math.round(p.hz);
    winners.set(key,(winners.get(key)||0)+1);
  }

  // Score คิดจาก Prominence, Hold, Count, Decay
  function computeScores(peaks){
    const promRef=12, holdRef=3, decayRef=1.5;
    let maxCount = 0;
    winners.forEach(v=>{if(v>maxCount) maxCount=v;});
    const scored = [];
    for(const p of peaks){
      const fr = Math.round(p.hz);
      const count = winners.get(fr)||0;

      const promN = clamp((p.prom||0)/promRef,0,1);
      const holdN = clamp((p.holdSec||0)/holdRef,0,1);
      const cntN  = (maxCount>0)? (count/maxCount) : 0;
      const decN  = clamp((p.decay||0)/decayRef,0,1);

      const score = 100*(0.30*promN + 0.30*holdN + 0.20*cntN + 0.20*decN);
      scored.push({
        hz: fr, score, parts:{promN,holdN,cntN,decN}, src:p, count
      });
    }
    for(const [fr,c] of winners){
      if(!scored.some(x=>x.hz===fr)){
        const dec = peakMemo.get(fr)?.lastDecay ?? 0;
        const promN=0, holdN=0, decN=clamp(dec/1.5,0,1), cntN = maxCount? c/maxCount : 0;
        const score = 100*(0.30*promN + 0.30*holdN + 0.20*cntN + 0.20*decN);
        scored.push({hz:fr,score,parts:{promN,holdN,cntN,decN},src:null,count:c});
      }
    }
    scored.sort((a,b)=>b.score-a.score);
    return scored.slice(0,3);
  }

  // ====== Renderers ======
  function renderPeaks(peaks){
    const rows=[];
    for(let i=0;i<3;i++){
      const p = peaks[i];
      if(!p){
        rows.push(`<tr><td colspan="5" class="muted">—</td></tr>`);
        continue;
      }
      const highlight = watch.some(h=>Math.abs(h-p.hz)<(hzPerBin()*1.5));
      rows.push(`<tr>
        <td class="mono">${Math.round(p.hz)} ${highlight?'<span class="badge">watch</span>':''}</td>
        <td class="mono">${p.level?.toFixed(1)??'—'}</td>
        <td class="mono">${p.prom?.toFixed(1)??'—'}</td>
        <td class="mono">${p.holdSec?.toFixed(2)??'—'}</td>
        <td class="mono">${p.decay!=null ? p.decay.toFixed(2) : '—'}</td>
      </tr>`);
    }
    tblPeaks.innerHTML = rows.join('');
  }

  function renderWinners(){
    const arr=[...winners.entries()].map(([hz,c])=>({hz,c}));
    arr.sort((a,b)=>b.c-a.c);
    const rows=[];
    for(let i=0;i<3;i++){
      const w = arr[i];
      if(!w){ rows.push(`<tr><td colspan="2" class="muted">—</td></tr>`); continue; }
      rows.push(`<tr><td class="mono">${w.hz}</td><td class="mono">${w.c}</td></tr>`);
    }
    tblWinners.innerHTML = rows.join('');
  }

  function renderScores(list){
    scoresBox.innerHTML = '';
    for(let i=0;i<3;i++){
      const s = list[i];
      if(!s){
        scoresBox.innerHTML += `<div class="card" style="flex:1 1 320px;min-width:260px">
          <div class="muted">—</div></div>`;
        continue;
      }
      const pct = clamp(s.score,0,100).toFixed(1);
      const p = s.parts;
      const bar = `<div class="bar"><i style="width:${pct}%"></i></div>`;
      const noteName = hzToNoteName(s.hz);
      scoresBox.innerHTML += `<div class="card" style="flex:1 1 320px;min-width:260px">
        <div class="ctl" style="justify-content:space-between"><div>
          <div class="mono" style="font-size:18px">${s.hz} Hz <span class="muted">(${noteName})</span></div>
          <div class="muted">Score</div></div>
          <div class="mono" style="font-size:22px;font-weight:800">${pct}</div>
        </div>
        ${bar}
        <div class="note" style="margin-top:6px">
          P:${Math.round(p.promN*100)}% · H:${Math.round(p.holdN*100)}% · C:${Math.round(p.cntN*100)}% · D:${Math.round(p.decN*100)}%
        </div>
      </div>`;
    }
  }

  // ====== Main loop ======
  function loop(){
    if(!ctx) return;
    const {peaks,overall} = getPeaks();
    updateHolds(peaks);
    updateWinners(peaks, overall);
    renderPeaks(peaks);
    renderWinners();
    const topScores = computeScores(peaks);
    renderScores(topScores);
    raf = requestAnimationFrame(loop);
  }

  // init
  renderPeaks([]);
  renderWinners([]);
  renderScores([]);
  renderWatchlist();
})();
</script>
</body>
</html>
